<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_60) on Mon Mar 26 20:42:15 PDT 2018 -->
<title>THF</title>
<meta name="date" content="2018-03-26">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="THF";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/articulate/sigma/trans/SUMOKBtoTPTPKB.OrderedFormulae.html" title="class in com.articulate.sigma.trans"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/articulate/sigma/trans/TPTP2SUMO.html" title="class in com.articulate.sigma.trans"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/articulate/sigma/trans/THF.html" target="_top">Frames</a></li>
<li><a href="THF.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.articulate.sigma.trans</div>
<h2 title="Class THF" class="title">Class THF</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.articulate.sigma.trans.THF</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">THF</span>
extends java.lang.Object</pre>
<div class="block">This class handles the conversion of problems (= axioms + queries)
 from their KIF representation into a THF representation; THF is the 
 TPTP standard for classical higher-order logic, i.e. Church's simple
 theory.

 The main function provided is KIF2THF(KIFaxioms,KIFqueries,KnowledgeBase)

 A challenge part in this transformation is the computation of an appropriate
 typing for the KIF terms and formulas. This is partly non-trivial.
 The conversion is intented to work purely syntactically (when no
 typing-relevant information from SUMO is available) or mixed 
 syntactically-semantically (when typing-relevant information from 
 SUMO is available). 

 A small example:
 The KIF Problem with axioms 

  (holdsDuring (YearFN n2009) (enjoys Mary Cooking))
  (holdsDuring (YearFN n2009) (=> (instance ?X Female) (wants Ben ?X)))
  (holdsDuring ?X (instance Mary Female))

  and Query
 
  (holdsDuring ?X (and (?Y Mary Cooking) (wants ?Z Mary)))

 is tranlated into the THF problem:
 
  %%% The extracted Signature %%%
   thf(holdsDuring,type,(holdsDuring: ($i>$o>$o))).
   thf(enjoys_THFTYPE_IiioI,type,(enjoys_THFTYPE_IiioI: ($i>$i>$o))).
   thf(female,type,(female: $i)).
   thf(n2009,type,(n2009: $i)).
   thf(cooking,type,(cooking: $i)).
   thf(ben,type,(ben: $i)).
   thf(yearFN_THFTYPE_IiiI,type,(yearFN_THFTYPE_IiiI: ($i>$i))).
   thf(mary,type,(mary: $i)).
   thf(wants,type,(wants: ($i>$i>$o))).
   thf(instance_THFTYPE_IiioI,type,(instance_THFTYPE_IiioI: ($i>$i>$o))).

  %%% The translated axioms %%%
   thf(ax,axiom,((! [X: $i]: (holdsDuring @ X @ (instance_THFTYPE_IiioI @ mary @ female))))).
   thf(ax,axiom,((! [X: $i]: (holdsDuring @ (yearFN_THFTYPE_IiiI @ n2009) @ ((instance_THFTYPE_IiioI @ X @ female) => (wants @ ben @ X)))))).
   thf(ax,axiom,((holdsDuring @ (yearFN_THFTYPE_IiiI @ n2009) @ (enjoys_THFTYPE_IiioI @ mary @ cooking)))).
  
  %%% The translated conjectures %%%
   thf(con,conjecture,((? [X: $i,Y: $i,Z: $i]: (holdsDuring @ X @ ((enjoys_THFTYPE_IiioI @ mary @ Y) & (wants @ Z @ mary)))))).

 This THF problem can be solved effectively by TPTP THF compliant higher-order theorem provers.

 The transformation often needs to introduce several
 'copies' of KIF constants for different THF types. Therefore some constant
 symbols become tagged with type information during the transformation process.
 Example for tagged contant symbols above enjoys_THFTYPE_IiioI and 
 instance_THFTYPE_IiioI.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../com/articulate/sigma/trans/THF.html#THF--">THF</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/articulate/sigma/trans/THF.html#KIF2THF-java.util.Collection-java.util.Collection-com.articulate.sigma.KB-">KIF2THF</a></span>(java.util.Collection&lt;<a href="../../../../com/articulate/sigma/Formula.html" title="class in com.articulate.sigma">Formula</a>&gt;&nbsp;axiomsC,
       java.util.Collection&lt;<a href="../../../../com/articulate/sigma/Formula.html" title="class in com.articulate.sigma">Formula</a>&gt;&nbsp;conjecturesC,
       <a href="../../../../com/articulate/sigma/KB.html" title="class in com.articulate.sigma">KB</a>&nbsp;kb)</code>
<div class="block">public String KIF2THF(Collection<Formula> axioms, Collection<Formula> conjectures, KB kb) {
        // string builders for the essential results of the translation:
        // signature, axioms, and conjectures
        StringBuilder signatureResult = new StringBuilder();    
        signatureResult.append("\n%%% The extracted Signature %%%");
        StringBuilder axiomsResult = new StringBuilder();
        axiomsResult.append("\n\n%%% The translated axioms %%%");
        StringBuilder conjecturesResult = new StringBuilder();  
        conjecturesResult.append("\n\n%%% The translated conjectures %%%");
        // tags and a map to distinguish axioms from conjectures
        String axTag = "ax";
        String conTag = "con";
        HashMap taggedFormulas = new HashMap();
        for (Iterator iter = axioms.iterator(); iter.hasNext();) {
            Formula ax = (Formula) iter.next();
            taggedFormulas.put(ax,axTag);
        }
        for (Iterator iter = conjectures.iterator(); iter.hasNext();) {
            Formula con = (Formula) iter.next();
            taggedFormulas.put(con,conTag);
        }
        // the main loop; we proceed formula by formula and work with side effects
        // to variables introduced above (I know that this is terrible programming style!) 
        for (Iterator iter = taggedFormulas.keySet().iterator(); iter.hasNext();) {
            Formula form = (Formula) iter.next();
            // formula f contains the explicitly quantified formula under
            // consideration, the quantifier (universal/existential) is 
            // determined correctly for axioms and conjectures 
            Formula f = new Formula();
            if (taggedFormulas.get(form).equals(axTag)) {
                f.read(form.makeQuantifiersExplicit(false));
            }
            else if (taggedFormulas.get(form).equals(conTag)) {
                f.read(form.makeQuantifiersExplicit(true));
            }
            System.out.println("\nKIF2THF -- translating KIF formula: " + f.theFormula.trim());
            // we request some semantic type-relevant information on the function and
            // relation symbols involved; this information is used with priority below
            HashMap relTypeInfo = f.gatherRelationsWithArgTypes(kb);
            // we initialize the terms-to-types mapping and start the actual translation 
            terms = new HashMap();
            String res = toTHF1(f,boolTp,relTypeInfo);
            // toTHF1 may return a THF translation that still contains many occurences
            // of the (kind of) polymorphic 'unkownTp' and in this case we apply further 
            // translation attempts employing the incrementially refined term-to-type 
            // information.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/articulate/sigma/trans/THF.html#main-java.lang.String:A-">main</a></span>(java.lang.String[]&nbsp;args)</code>
<div class="block">A test method.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="THF--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>THF</h4>
<pre>public&nbsp;THF()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="KIF2THF-java.util.Collection-java.util.Collection-com.articulate.sigma.KB-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KIF2THF</h4>
<pre>public&nbsp;java.lang.String&nbsp;KIF2THF(java.util.Collection&lt;<a href="../../../../com/articulate/sigma/Formula.html" title="class in com.articulate.sigma">Formula</a>&gt;&nbsp;axiomsC,
                                java.util.Collection&lt;<a href="../../../../com/articulate/sigma/Formula.html" title="class in com.articulate.sigma">Formula</a>&gt;&nbsp;conjecturesC,
                                <a href="../../../../com/articulate/sigma/KB.html" title="class in com.articulate.sigma">KB</a>&nbsp;kb)</pre>
<div class="block">public String KIF2THF(Collection<Formula> axioms, Collection<Formula> conjectures, KB kb) {
        // string builders for the essential results of the translation:
        // signature, axioms, and conjectures
        StringBuilder signatureResult = new StringBuilder();    
        signatureResult.append("\n%%% The extracted Signature %%%");
        StringBuilder axiomsResult = new StringBuilder();
        axiomsResult.append("\n\n%%% The translated axioms %%%");
        StringBuilder conjecturesResult = new StringBuilder();  
        conjecturesResult.append("\n\n%%% The translated conjectures %%%");
        // tags and a map to distinguish axioms from conjectures
        String axTag = "ax";
        String conTag = "con";
        HashMap taggedFormulas = new HashMap();
        for (Iterator iter = axioms.iterator(); iter.hasNext();) {
            Formula ax = (Formula) iter.next();
            taggedFormulas.put(ax,axTag);
        }
        for (Iterator iter = conjectures.iterator(); iter.hasNext();) {
            Formula con = (Formula) iter.next();
            taggedFormulas.put(con,conTag);
        }
        // the main loop; we proceed formula by formula and work with side effects
        // to variables introduced above (I know that this is terrible programming style!) 
        for (Iterator iter = taggedFormulas.keySet().iterator(); iter.hasNext();) {
            Formula form = (Formula) iter.next();
            // formula f contains the explicitly quantified formula under
            // consideration, the quantifier (universal/existential) is 
            // determined correctly for axioms and conjectures 
            Formula f = new Formula();
            if (taggedFormulas.get(form).equals(axTag)) {
                f.read(form.makeQuantifiersExplicit(false));
            }
            else if (taggedFormulas.get(form).equals(conTag)) {
                f.read(form.makeQuantifiersExplicit(true));
            }
            System.out.println("\nKIF2THF -- translating KIF formula: " + f.theFormula.trim());
            // we request some semantic type-relevant information on the function and
            // relation symbols involved; this information is used with priority below
            HashMap relTypeInfo = f.gatherRelationsWithArgTypes(kb);
            // we initialize the terms-to-types mapping and start the actual translation 
            terms = new HashMap();
            String res = toTHF1(f,boolTp,relTypeInfo);
            // toTHF1 may return a THF translation that still contains many occurences
            // of the (kind of) polymorphic 'unkownTp' and in this case we apply further 
            // translation attempts employing the incrementially refined term-to-type 
            // information. This is done via repetitive calls to toTHF2. This loop 
            // terminates when the signature localsig, which is storing the latest constant-to-symbols
            // mapping, is free of occurences of the 'unknownTp'.
            // toTHF2 always starts a fresh translation attempt for the KIF formula stored in 
            // variable kifFormula, which may itself be modified by renamings of symbols.
            // It is thus important in the code to maintain a correspondence between the symbols in 
            // this kifFormula, the terms-to-type mappings, and the incrementially refined THF
            // translation; the handling of e.g. the different upper and lower case conventions 
            // between KIF and TPTP THF further complicates matters. This issue makes the code
            // particularly fragile, also since it exploits string processing way to much.
            HashMap oldsig = new HashMap();
            kifFormula = new StringBuilder();
            while (containsUnknownTp(localsig)) {
                if (!oldsig.equals(localsig)) {
                    THFdebugOut("\n Debug: Enter new regular topmost call to THF2");
                    oldsig = (HashMap) localsig.clone();
                    res = toTHF2(f);
                    f = new Formula();
                    f.read(kifFormula.toString());
                    kifFormula = new StringBuilder();
                    localsig = clearMapFor(localsig,f.theFormula.trim());
                    subst = clearMapFor(subst,f.theFormula.trim());
                }
                else {
                    THFdebugOut("\n Debug: Enter new topmost call to THF2 with constant symbol substitution");
                    oldsig = (HashMap) localsig.clone();
                    Set keyset = subst.keySet();
                    THFdebugOut("   Debug: f before is " + f.toString());
                    THFdebugOut("   Debug: subst is " + subst.toString());
                    String fsubst = f.toString();
                    for (Iterator it = keyset.iterator(); it.hasNext();) {
                        String key = (String) it.next();
                        String keysubst = (String) subst.get(key);
                        THFdebugOut("\n    Debug: fsubst before is " + fsubst);
                        THFdebugOut("    Debug: key is " + key + " and keysubst is " + keysubst);
                        fsubst = applySubstTo(key,keysubst,fsubst);
                        THFdebugOut("    Debug: fsubst after is " + fsubst);
                    }
                    f = new Formula();
                    f.read(fsubst);
                    THFdebugOut("\n   Debug: f after is " + f.toString());
                    res = toTHF2(f);
                    f = new Formula();
                    f.read(kifFormula.toString());
                    kifFormula = new StringBuilder();
                    localsig = clearMapFor(localsig,f.theFormula.trim());
                    subst = clearMapFor(subst,f.theFormula.trim());
                }
            }
            // this final one-more call to toTHF2 seems not needed anymore
            // but is was in earlier versions.
            // if  (res.contains(unknownTp)) {
            // THFdebugOut("\n Debug: Enter one more topmost call to THF2");
            res = toTHF2(f);
            // }
            // now we can add the computed THF translation for 
            // formula f to the appropriate result string builder
            if (taggedFormulas.get(form).equals(axTag)) {
                String resAx = "";
                if (res.startsWith("%")) {
                    resAx = "\n" + res;
                }
                else {
                    resAx = "\n thf(ax,axiom,(" + res + ")).";
                }
                System.out.println("KIF2THF -- result: " + resAx);
                axiomsResult.append(resAx);
            }
            else if (taggedFormulas.get(form).equals(conTag)) {
                String resCon = "";
                if (res.startsWith("%")) {
                    resCon = "\n" + res;
                }
                else {
                    resCon = "\n thf(con,conjecture,(" + res + ")).";
                }
                System.out.println("KIF2THF -- result: " + resCon);
                conjecturesResult.append(resCon);
            }
            else {
                axiomsResult.append("\n something went wrong for " + form + "   " + res);
            }
            overallsig.putAll(localsig);
            localsig = new HashMap();
        }
        // After the translation processed has terminated for all formulas f, we read off
        // the THF signature from the map 'overallsig'
        Set constants = overallsig.keySet();    
        for (Iterator it = constants.iterator(); it.hasNext();) {
            String con = (String) it.next();
            String ty = (String) overallsig.get(con);
            signatureResult.append("\n thf(" + con + ",type,(" + con + ": " + ty + ")).");
        }
        String result = signatureResult.toString() + axiomsResult.toString() + conjecturesResult.toString();
        return result.toString();
    }</div>
</li>
</ul>
<a name="main-java.lang.String:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(java.lang.String[]&nbsp;args)</pre>
<div class="block">A test method.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/articulate/sigma/trans/SUMOKBtoTPTPKB.OrderedFormulae.html" title="class in com.articulate.sigma.trans"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/articulate/sigma/trans/TPTP2SUMO.html" title="class in com.articulate.sigma.trans"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/articulate/sigma/trans/THF.html" target="_top">Frames</a></li>
<li><a href="THF.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
